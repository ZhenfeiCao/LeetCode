# 123题解
考察点：买卖股票的最佳时机 III

#### 方法一：动态规划 三维数组

在递归实现时，我们用了三个变量：index、status、k。这里我们定义一个三维数组
$dp[n][3][2]$ 这里的n表示天数

$dp[i][0][0]$：表示第i天交易了0次时卖出后的累计最大利润
$dp[i][0][1]$：表示第i天交易了0次时买入后的累计最大利润
$dp[i][1][0]$：表示第i天交易了1次时卖出后的累计最大利润
$dp[i][1][1]$：表示第i天交易了1次时买入后的累计最大利润
$dp[i][2][0]$：表示第i天交易了2次时卖出后的累计最大利润
$dp[i][2][1]$：表示第i天交易了2次时买入后的累计最大利润
注意，最后一个$dp[i][2][1]$ 实际是不存在的，因为交易两次后，就不能再买入了。

我们来分析一下上面定义的dp数组：

![](https://pic.leetcode-cn.com/f11fe32b226215bf37e7704b55ac184a98905033951755b8232fdccd2ad56973-4.jpg)

$dp[i][0][0]$：对应于初始状态，第i天0次交易卖出，既然都没交易，那何来卖出呢，所以只能是0。
$dp[i][0][1]和dp[i][1][0]$ 这两个是一对，对应到上图中就是第一次买入、第一次卖出。
$dp[i][1][1]和dp[i][2][0]$ 这两个也是一对，对应到上图中就是第二次买入、第二次卖出。

从这里我们也能看出为什么$dp[i][2][1]$是无效的。

再看一下状态转换公式如何推导的
前面我们分析过了，买入1这个状态只能从两个地方转换来，买入1本身(保持不动)，或者是初始状态转换而来。
而卖出1这个状态，也只能从两个地方转换而来，卖出1本身(保持不动)，或者从买入1转来。

![](https://pic.leetcode-cn.com/9afe05eaf8cdfd9db0c505e1a4c36f21cac4f10e37cfb76c0cad575094eff612-5.jpg)

那么根据上面描述，我们可以算出第一次买卖的DP公式：

```
第一次买入：从初始状态转换而来，或者第一次买入后保持不动
dp[i][0][1] = max(dp[i-1][0][1],dp[i-1][0][0]-prices[i])

第一次卖出：从第一次买入转换而来，或者第一次卖出后保持不动
dp[i][1][0] = max(dp[i-1][1][0],dp[i-1][0][1]+prices[i])
```

再来分下一下第二次的买卖过程：
同样，第二次买入只能从 第一次买出转换来，或者保持不动
第二次卖出只能从第二次买入转换来，或者保持不动

![](https://pic.leetcode-cn.com/fe39e1fd05038b159679b5a014a65583495e34ff96227d1bae775ccc9742531d-6.jpg)

么根据上面描述，我们可以算出第二次买卖的DP公式：

```
第二次买入：从第一次卖出转换而来，或者第二次买入后保持不动
dp[i][1][1] = max(dp[i-1][1][1],dp[i-1][1][0]-prices[i])


第二次卖出：从第二次买入转换而来，或者第二次卖出后保持不动
dp[i][2][0] = max(dp[i-1][2][0],dp[i-1][1][1]+prices[i])
```

我们把第一次买卖、第二次买卖的DP公式合到一起，就拿到了完整的推导过程。
之后我们还需要处理一下 第一天的初始化状态(具体请看代码部分)
最后求的利润最大值就保存在 $dp[n-1][0][0]$、$dp[n-1][0][1]$、$dp[n-1][1][0]$、$dp[n-1][1][1]$、$dp[n-1][2][0]$中，我们求出这几个值的max再返回就可以了。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null || prices.length==0) {
            return 0;
        }
        int n = prices.length;
        //定义三维数组，第i天、交易了多少次、当前的买卖状态
        int[][][] dp = new int[n][3][2];
        //初始化第一天，这里的dp[0][2][1]可以不用管，后面也不会用到   
        dp[0][0][0] = 0;
        dp[0][0][1] = -prices[0];
        dp[0][1][0] = 0;
        dp[0][1][1] = -prices[0];
        dp[0][2][0] = 0;
        dp[0][2][1] = -prices[0];
        for(int i=1;i<n;++i) {
            //dp[i][0][0]相当于初始状态，它只能从初始状态转换来
            dp[i][0][0] = dp[i-1][0][0];
            //处理第一次买入、第一次卖出
            dp[i][0][1] = Math.max(dp[i-1][0][1],dp[i-1][0][0]-prices[i]);
            dp[i][1][0] = Math.max(dp[i-1][1][0],dp[i-1][0][1]+prices[i]);
            //处理第二次买入、第二次卖出
            dp[i][1][1] = Math.max(dp[i-1][1][1],dp[i-1][1][0]-prices[i]);
            dp[i][2][0] = Math.max(dp[i-1][2][0],dp[i-1][1][1]+prices[i]);
        }
        //返回最大值
        int a = Math.max(dp[n-1][0][0],dp[n-1][0][1]);
        int b = Math.max(dp[n-1][1][0],dp[n-1][1][1]);
        return Math.max(Math.max(a,b),dp[n-1][2][0]);
    }
}
```

#### 方法二：动态规划 二维数组

这我们定义一个二维数组 $dp[n$][5]
这的n表示天数，5表示5种不同的状态

其实这个转换跟 三维数组的有点类似，在三维数组中我们定义了交易次数、买卖状态。 因为交易次数和买卖状态都是常数个，所以我们把这两者整合到一起了。

我们定义了5种状态来代替三维数组中的交易次数和买卖状态，物种状态分别如上图

$dp[i][0] $初始化状态
$dp[i][1] $第一次买入
$dp[i][2]$ 第一次卖出
$dp[i][3]$ 第二次买入
$dp[i][4]$ 第二次卖出

根据上面的转换关系，我们来推到一下DP公式
首先是第一次买卖：

```
第一次买入：从初始状态转换而来，或者第一次买入后保持不动
dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i])
            
第一次卖出：从第一次买入转换而来，或者第一次卖出后保持不动
dp[i][2] = max(dp[i-1][2],dp[i-1][1]+prices[i])
```

第二次买卖的DP推到如下：

```
第二次买入：从第一次卖出转换而来，或者第二次买入后保持不动
dp[i][3] = max(dp[i-1][3],dp[i-1][2]-prices[i])


第二次卖出：从第二次买入转换而来，或者第二次卖出后保持不动
dp[i][4] = max(dp[i-1][4],dp[i-1][3]+prices[i])
```

把上面两次买卖推导公式整合到一起就是完整的计算过程了，第一天的初始化过程请查看代码部分。
最后求的利润最大值就保存在 $dp[n-1][0]$、$dp[n-1][1]$、$dp[n-1][2]$、$dp[n-1][3]$、$dp[n-1][4]$中，我们求出这几个值的max再返回就可以了。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null || prices.length==0) {
            return 0;
        }
        int n = prices.length;
        //定义二维数组，5种状态  
        int[][] dp = new int[n][5];
        //初始化第一天的状态
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;
        for(int i=1;i<n;++i) {
            //dp[i][0]相当于初始状态，它只能从初始状态转换来
            dp[i][0] = dp[i-1][0];
            //处理第一次买入、第一次卖出
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
            dp[i][2] = Math.max(dp[i-1][2],dp[i-1][1]+prices[i]);
            //处理第二次买入、第二次卖出
            dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]-prices[i]);
            dp[i][4] = Math.max(dp[i-1][4],dp[i-1][3]+prices[i]);
        }
        //返回最大值
        return Math.max(Math.max( Math.max(dp[n-1][0],dp[n-1][1]),Math.max(dp[n-1][2],dp[n-1][3]) ),dp[n-1][4]);
    }
}
```

#### 方法三：动态规划 空间优化

通过二维数组的5个状态的定义，我们发现，每执行到一个状态时，只需要当前状态和前面一次状态的值就可以了。
比如要计算 第一次卖出(卖出1)这个状态，就只需要买入1和卖出1这两个状态就可以了。

![](https://pic.leetcode-cn.com/46352fb0cfe9ab12776bc98d2ebdeaf730854ed4d7da64e83d9eeea1766a3009-8.jpg)

计算 $dp[i][x]$ 时(这里的x表示任意状态)，只需要两个值：

$dp[i-1][x]$
$dp[i-1][x-1]$ (if x>0)
即求完第i天的值后，就不需要第i-1天的数据了，dp数组是不断滚动更新的，所以我们可以用5个变量来代替二维数组。

dp0：初始化状态
dp1：第一次买入
dp2：第一次卖出
dp3：第二次买入
dp4：第二次卖出
根据上面的转换关系，我们来推到一下DP公式
首先是第一次买卖：

```
第一次买入：从初始状态转换而来，或者第一次买入后保持不动
dp1 = max(dp1,dp0-prices[i])
            
第一次卖出：从第一次买入转换而来，或者第一次卖出后保持不动
dp2 = max(dp2,dp1+prices[i])
```

第二次买卖的DP推导如下：

```
第二次买入：从第一次卖出转换而来，或者第二次买入后保持不动
dp3= max(dp3,dp2-prices[i])


第二次卖出：从第二次买入转换而来，或者第二次卖出后保持不动
dp4 = max(dp4,dp3+prices[i])
```

最后求的利润最大值就保存在 d0、dp1、dp2、dp3、dp4中，我们求出这几个值的max再返回就可以了。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null || prices.length==0) {
            return 0;
        }
        int n = prices.length;
        //定义5种状态，并初始化第一天的状态
        int dp0 = 0;
        int dp1 = -prices[0];
        int dp2 = 0;
        int dp3 = -prices[0];
        int dp4 = 0;
        for(int i=1;i<n;++i) {
            //这里省略dp0，因为dp0每次都是从上一个dp0来的相当于每次都是0
            //处理第一次买入、第一次卖出
            dp1 = Math.max(dp1,dp0-prices[i]);
            dp2 = Math.max(dp2,dp1+prices[i]);
            //处理第二次买入、第二次卖出
            dp3 = Math.max(dp3,dp2-prices[i]);
            dp4 = Math.max(dp4,dp3+prices[i]);
        }
        //返回最大值
        return Math.max(0,Math.max(Math.max(dp1,dp2),Math.max(dp3,dp4)));
    }
}
```

